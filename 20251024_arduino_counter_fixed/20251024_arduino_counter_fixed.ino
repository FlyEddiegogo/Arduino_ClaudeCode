/*
 * ============================================================================
 * Arduino 物件計數系統 - 紅外線感測器 + 74LS47 BCD解碼器 + 七段顯示器
 * ============================================================================
 * 版本: 3.0 Debug修正版
 * 功能: 解決物體離開時重複計數的問題
 * 作者: 專業程式工程師
 * 日期: 2025
 * 
 * 主要修正:
 * 1. 修正十位數和個位數顯示位置錯誤
 * 2. 改進中斷觸發邏輯，避免重複計數
 * 3. 加強防抖動機制
 * 4. 每行程式都加上詳細中文註解
 * ============================================================================
 */

// ============================================================================
// 硬體腳位定義區塊
// ============================================================================

// ── 左邊顯示器（十位數）對應74LS47的BCD輸入腳位定義 ──
#define LEFT_A   7    // 十位數BCD的A位元(LSB,最低有效位,權重=1)接Arduino D7腳位
#define LEFT_B   8    // 十位數BCD的B位元(權重=2)接Arduino D8腳位
#define LEFT_C   9    // 十位數BCD的C位元(權重=4)接Arduino D9腳位
#define LEFT_D   10   // 十位數BCD的D位元(MSB,最高有效位,權重=8)接Arduino D10腳位

// ── 右邊顯示器（個位數）對應74LS47的BCD輸入腳位定義 ──
#define RIGHT_A  3    // 個位數BCD的A位元(LSB,權重=1)接Arduino D3腳位
#define RIGHT_B  4    // 個位數BCD的B位元(權重=2)接Arduino D4腳位
#define RIGHT_C  5    // 個位數BCD的C位元(權重=4)接Arduino D5腳位
#define RIGHT_D  6    // 個位數BCD的D位元(MSB,權重=8)接Arduino D6腳位

// ============================================================================
// 感測器參數設定區塊
// ============================================================================

// ── 感測器硬體設定 ──
#define SENSOR_PIN        2   // 紅外線感測器的數位輸出腳位接到Arduino D2(支援硬體中斷INT0)
#define SENSOR_ACTIVE_LOW 1   // 1=物體遮擋時輸出LOW(大部分感測器的邏輯)；0=遮擋時輸出HIGH
#define USE_INTERNAL_PULLUP 0 // 1=啟用D2內建上拉電阻(適用開集極輸出)；0=感測器模組自帶推挽輸出

// ── 防抖動與防重複計數參數 ──
const uint16_t DEBOUNCE_MS = 100;     // 防抖動時間(毫秒)，物體通過後的最短間隔時間
const uint16_t BLOCK_TIME_MS = 300;   // 封鎖時間(毫秒)，物體離開後的額外等待時間，避免重複計數

// ============================================================================
// 系統狀態定義
// ============================================================================

// 定義感測器狀態機的三個狀態
#define STATE_IDLE      0  // 閒置狀態：等待物體進入
#define STATE_COUNTING  1  // 計數狀態：物體正在通過，已計數
#define STATE_BLOCKING  2  // 封鎖狀態：物體離開後的保護期，防止重複觸發

// ============================================================================
// 函式原型宣告(避免編譯錯誤)
// ============================================================================

void outputBCD(uint8_t digit, bool toRight);  // 將0~9的數字轉換成BCD碼並輸出到指定的74LS47
void displayNumber(uint8_t n);                // 將兩位數分別顯示在十位和個位七段顯示器上
void sensorISR();                             // 感測器中斷服務程序(Interrupt Service Routine)

// ============================================================================
// 全域變數宣告(使用volatile確保中斷安全)
// ============================================================================

// ── 計數與狀態變數(volatile表示會在中斷中被修改) ──
volatile uint8_t  g_count = 0;          // 目前的計數值(0~99循環)
volatile uint32_t g_lastTriggerMs = 0;  // 上次有效觸發的時間戳記(毫秒)
volatile uint32_t g_blockStartMs = 0;   // 封鎖開始的時間戳記(毫秒)
volatile uint8_t  g_state = STATE_IDLE; // 目前的狀態機狀態
volatile bool g_needUpdate = false;     // 顯示更新旗標(true=需要更新顯示)

// ── 顯示快取變數(避免重複更新相同數值) ──
uint8_t g_lastShown = 255;              // 上次顯示的數值(初始化為不可能的值255,確保第一次會更新)

// ── 統計變數(用於除錯和性能監控) ──
uint32_t g_totalTriggers = 0;           // 總觸發次數(包含被濾除的)
uint32_t g_rejectedTriggers = 0;        // 被濾除的觸發次數

// ============================================================================
// setup() 函式 - 系統初始化(Arduino開機時執行一次)
// ============================================================================

void setup() {
  // ────────────────────────────────────────────────────
  // 步驟1: 設定所有BCD輸出腳位為OUTPUT模式
  // ────────────────────────────────────────────────────
  
  // 設定左邊(十位數)74LS47的BCD輸入腳位
  pinMode(LEFT_A,  OUTPUT);  // 設定D7為輸出模式,控制十位數的A位元
  pinMode(LEFT_B,  OUTPUT);  // 設定D8為輸出模式,控制十位數的B位元
  pinMode(LEFT_C,  OUTPUT);  // 設定D9為輸出模式,控制十位數的C位元
  pinMode(LEFT_D,  OUTPUT);  // 設定D10為輸出模式,控制十位數的D位元
  
  // 設定右邊(個位數)74LS47的BCD輸入腳位
  pinMode(RIGHT_A, OUTPUT);  // 設定D3為輸出模式,控制個位數的A位元
  pinMode(RIGHT_B, OUTPUT);  // 設定D4為輸出模式,控制個位數的B位元
  pinMode(RIGHT_C, OUTPUT);  // 設定D5為輸出模式,控制個位數的C位元
  pinMode(RIGHT_D, OUTPUT);  // 設定D6為輸出模式,控制個位數的D位元

  // ────────────────────────────────────────────────────
  // 步驟2: 設定感測器輸入腳位模式
  // ────────────────────────────────────────────────────
  
  if (USE_INTERNAL_PULLUP) {                    // 檢查是否需要啟用內建上拉電阻
    pinMode(SENSOR_PIN, INPUT_PULLUP);          // 設定D2為輸入模式並啟用內建上拉電阻(適用開集極輸出感測器)
  } else {
    pinMode(SENSOR_PIN, INPUT);                 // 設定D2為純輸入模式(適用推挽輸出感測器)
  }

  // ────────────────────────────────────────────────────
  // 步驟3: 初始化序列埠通訊(用於除錯)
  // ────────────────────────────────────────────────────
  
  Serial.begin(9600);                           // 設定序列埠鮑率為9600 bps
  Serial.println(F("===================================="));
  Serial.println(F("物件計數系統 v3.0 Debug修正版"));
  Serial.println(F("===================================="));
  Serial.println(F("系統初始化中..."));
  Serial.print(F("感測器邏輯: "));
  if (SENSOR_ACTIVE_LOW) {
    Serial.println(F("遮擋時輸出LOW (Active Low)"));
  } else {
    Serial.println(F("遮擋時輸出HIGH (Active High)"));
  }
  Serial.print(F("防抖動時間: "));
  Serial.print(DEBOUNCE_MS);
  Serial.println(F(" ms"));
  Serial.print(F("封鎖保護時間: "));
  Serial.print(BLOCK_TIME_MS);
  Serial.println(F(" ms"));

  // ────────────────────────────────────────────────────
  // 步驟4: 初始化系統變數
  // ────────────────────────────────────────────────────
  
  g_count = 0;                                  // 將計數器歸零
  g_state = STATE_IDLE;                        // 設定狀態機為閒置狀態
  g_lastTriggerMs = 0;                         // 清除上次觸發時間
  g_blockStartMs = 0;                          // 清除封鎖開始時間
  g_needUpdate = false;                        // 清除更新旗標
  g_totalTriggers = 0;                         // 清除總觸發次數
  g_rejectedTriggers = 0;                      // 清除被濾除次數

  // ────────────────────────────────────────────────────
  // 步驟5: 顯示初始值00
  // ────────────────────────────────────────────────────
  
  displayNumber(g_count);                      // 在七段顯示器上顯示00
  g_lastShown = g_count;                       // 記錄已顯示的值

  // ────────────────────────────────────────────────────
  // 步驟6: 設定硬體中斷(最後設定,確保其他初始化都完成)
  // ────────────────────────────────────────────────────
  
  // 重要: 使用CHANGE模式可以偵測HIGH→LOW和LOW→HIGH兩種變化
  // 這樣我們可以知道物體何時進入(遮擋)和離開(不遮擋)
  attachInterrupt(
    digitalPinToInterrupt(SENSOR_PIN),         // 將D2腳位號碼轉換為中斷編號(INT0)
    sensorISR,                                  // 指定中斷發生時要呼叫的函式
    CHANGE                                      // 觸發模式:訊號變化時觸發(包含上升緣和下降緣)
  );

  // ────────────────────────────────────────────────────
  // 步驟7: 系統啟動完成
  // ────────────────────────────────────────────────────
  
  Serial.println(F("系統初始化完成!"));
  Serial.println(F("準備開始計數..."));
  Serial.println(F("====================================\n"));
  
  delay(500);                                   // 延遲500ms讓硬體穩定
}

// ============================================================================
// loop() 函式 - 主迴圈(持續執行)
// ============================================================================

void loop() {
  // ────────────────────────────────────────────────────
  // 步驟1: 安全地讀取共享變數(使用臨界區保護)
  // ────────────────────────────────────────────────────
  
  noInterrupts();                               // 暫時禁用所有中斷,進入臨界區
  uint8_t currentCount = g_count;               // 複製當前計數值到區域變數
  bool needUpdate = g_needUpdate;               // 複製更新旗標到區域變數
  if (needUpdate) {
    g_needUpdate = false;                       // 清除更新旗標
  }
  uint8_t currentState = g_state;               // 複製當前狀態到區域變數
  uint32_t blockStart = g_blockStartMs;         // 複製封鎖開始時間到區域變數
  interrupts();                                 // 重新啟用中斷,離開臨界區

  // ────────────────────────────────────────────────────
  // 步驟2: 檢查是否需要更新顯示
  // ────────────────────────────────────────────────────
  
  if (needUpdate && (currentCount != g_lastShown)) {  // 如果有更新旗標且數值確實改變
    displayNumber(currentCount);                      // 更新七段顯示器顯示
    g_lastShown = currentCount;                       // 記錄已顯示的值
    
    // 輸出詳細的計數資訊到序列埠
    Serial.print(F("[計數] 當前值: "));
    Serial.print(currentCount);
    Serial.print(F(" | 總觸發: "));
    Serial.print(g_totalTriggers);
    Serial.print(F(" | 濾除: "));
    Serial.print(g_rejectedTriggers);
    Serial.print(F(" | 成功率: "));
    if (g_totalTriggers > 0) {
      float successRate = 100.0 * (g_totalTriggers - g_rejectedTriggers) / g_totalTriggers;
      Serial.print(successRate, 1);
      Serial.println(F("%"));
    } else {
      Serial.println(F("N/A"));
    }
  }

  // ────────────────────────────────────────────────────
  // 步驟3: 管理封鎖狀態的自動解除
  // ────────────────────────────────────────────────────
  
  // 如果目前在封鎖狀態,檢查是否已經過了封鎖時間
  if (currentState == STATE_BLOCKING) {
    uint32_t currentTime = millis();                  // 取得當前時間
    uint32_t blockDuration = currentTime - blockStart; // 計算封鎖已經過的時間
    
    if (blockDuration >= BLOCK_TIME_MS) {             // 如果已超過封鎖時間
      noInterrupts();                                  // 進入臨界區
      g_state = STATE_IDLE;                           // 將狀態改回閒置
      interrupts();                                    // 離開臨界區
      
      // 輸出除錯訊息
      Serial.println(F("[狀態] 封鎖解除,回到閒置狀態"));
    }
  }

  // ────────────────────────────────────────────────────
  // 步驟4: 主迴圈延遲(降低CPU使用率)
  // ────────────────────────────────────────────────────
  
  delay(10);                                          // 延遲10ms,避免過度占用CPU
  
  // 注意: 這裡可以加入其他功能,例如:
  // - 檢查重置按鈕
  // - 與其他設備通訊
  // - 儲存資料到EEPROM等
}

// ============================================================================
// sensorISR() - 感測器中斷服務程序
// ============================================================================
// 重要: ISR必須盡可能簡短快速,避免使用Serial.print或delay
// ============================================================================

void sensorISR() {
  // ────────────────────────────────────────────────────
  // 步驟1: 讀取感測器當前狀態和時間
  // ────────────────────────────────────────────────────
  
  uint32_t currentTime = millis();              // 取得當前系統時間(毫秒)
  uint8_t sensorLevel = digitalRead(SENSOR_PIN); // 讀取感測器當前電平(HIGH或LOW)
  
  // 根據設定判斷什麼電平代表物體遮擋
  const uint8_t ACTIVE_LEVEL = (SENSOR_ACTIVE_LOW ? LOW : HIGH);   // 遮擋時的電平
  const uint8_t INACTIVE_LEVEL = (SENSOR_ACTIVE_LOW ? HIGH : LOW); // 未遮擋時的電平
  
  // 增加總觸發次數(用於統計)
  g_totalTriggers++;
  
  // ────────────────────────────────────────────────────
  // 步驟2: 根據當前狀態和感測器電平執行狀態機邏輯
  // ────────────────────────────────────────────────────
  
  switch (g_state) {
    // ──────────────────────────────────────
    // 狀態: 閒置(等待物體進入)
    // ──────────────────────────────────────
    case STATE_IDLE:
      if (sensorLevel == ACTIVE_LEVEL) {        // 如果偵測到物體遮擋
        // 檢查防抖動(與上次有效觸發的時間間隔)
        uint32_t timeDiff = currentTime - g_lastTriggerMs;
        
        if (timeDiff < DEBOUNCE_MS) {           // 如果時間間隔太短
          g_rejectedTriggers++;                  // 增加被濾除計數
          return;                                // 視為抖動,直接返回
        }
        
        // 通過防抖動檢查,執行有效計數
        g_lastTriggerMs = currentTime;          // 更新上次觸發時間
        
        // 計數加一(帶溢位保護)
        uint8_t nextCount = g_count + 1;        // 計算下一個計數值
        if (nextCount >= 100) {                 // 如果超過99
          nextCount = 0;                         // 歸零(循環計數)
        }
        g_count = nextCount;                     // 更新計數值
        
        g_needUpdate = true;                     // 設定顯示更新旗標
        g_state = STATE_COUNTING;                // 轉換到計數狀態
      }
      break;
    
    // ──────────────────────────────────────
    // 狀態: 計數中(物體正在通過)
    // ──────────────────────────────────────
    case STATE_COUNTING:
      if (sensorLevel == INACTIVE_LEVEL) {      // 如果物體離開(不再遮擋)
        g_blockStartMs = currentTime;           // 記錄封鎖開始時間
        g_state = STATE_BLOCKING;               // 轉換到封鎖狀態
      }
      // 如果仍然是ACTIVE_LEVEL,保持在計數狀態,不做任何事
      break;
    
    // ──────────────────────────────────────
    // 狀態: 封鎖中(防止物體離開時的重複計數)
    // ──────────────────────────────────────
    case STATE_BLOCKING:
      // 在封鎖狀態下,忽略所有感測器變化
      // 等待主迴圈根據時間自動解除封鎖
      g_rejectedTriggers++;                     // 記錄被濾除的觸發
      break;
    
    // ──────────────────────────────────────
    // 預設情況(不應該發生)
    // ──────────────────────────────────────
    default:
      g_state = STATE_IDLE;                     // 重置為閒置狀態
      break;
  }
}

// ============================================================================
// outputBCD() - 將0~9數字轉換為BCD編碼並輸出到74LS47
// ============================================================================
// 參數說明:
// - digit: 要顯示的數字(0~9)
// - toRight: true=輸出到右邊(個位), false=輸出到左邊(十位)
// ============================================================================

void outputBCD(uint8_t digit, bool toRight) {
  // ────────────────────────────────────────────────────
  // 步驟1: 確保輸入在有效範圍內
  // ────────────────────────────────────────────────────
  
  digit %= 10;  // 使用模10運算確保digit在0~9範圍內
  
  // ────────────────────────────────────────────────────
  // 步驟2: 將十進位數字轉換為BCD二進位編碼
  // ────────────────────────────────────────────────────
  // BCD編碼說明:
  // - 使用4個位元表示0~9的數字
  // - A(bit0)=1, B(bit1)=2, C(bit2)=4, D(bit3)=8
  // 例如: 5 = 0101 (D=0,C=1,B=0,A=1)
  
  bool A = (digit & 0x01) != 0;  // 取出bit0(AND 0001),判斷A位元是否為1
  bool B = (digit & 0x02) != 0;  // 取出bit1(AND 0010),判斷B位元是否為1
  bool C = (digit & 0x04) != 0;  // 取出bit2(AND 0100),判斷C位元是否為1
  bool D = (digit & 0x08) != 0;  // 取出bit3(AND 1000),判斷D位元是否為1

  // ────────────────────────────────────────────────────
  // 步驟3: 根據目標位置輸出BCD編碼到對應腳位
  // ────────────────────────────────────────────────────
  
  if (toRight) {
    // 輸出到右邊顯示器(個位數)
    digitalWrite(RIGHT_A, A);    // 將A位元輸出到D3腳位
    digitalWrite(RIGHT_B, B);    // 將B位元輸出到D4腳位
    digitalWrite(RIGHT_C, C);    // 將C位元輸出到D5腳位
    digitalWrite(RIGHT_D, D);    // 將D位元輸出到D6腳位
  } else {
    // 輸出到左邊顯示器(十位數)
    digitalWrite(LEFT_A, A);     // 將A位元輸出到D7腳位
    digitalWrite(LEFT_B, B);     // 將B位元輸出到D8腳位
    digitalWrite(LEFT_C, C);     // 將C位元輸出到D9腳位
    digitalWrite(LEFT_D, D);     // 將D位元輸出到D10腳位
  }
  
  // BCD到七段顯示器的轉換由74LS47硬體自動完成
  // 74LS47會將BCD編碼轉換為對應的七段顯示器段碼
}

// ============================================================================
// displayNumber() - 顯示兩位數到七段顯示器
// ============================================================================
// 參數說明: n = 要顯示的數字(0~99)
// ============================================================================

void displayNumber(uint8_t n) {
  // ────────────────────────────────────────────────────
  // 步驟1: 確保輸入在有效範圍內
  // ────────────────────────────────────────────────────
  
  if (n > 99) {
    n = 99;  // 如果超過99,限制在最大值99
  }
  
  // ────────────────────────────────────────────────────
  // 步驟2: 分離十位數和個位數
  // ────────────────────────────────────────────────────
  
  uint8_t tens = n / 10;  // 十位數 = n除以10的商(整數除法自動捨去小數)
  uint8_t ones = n % 10;  // 個位數 = n除以10的餘數
  
  // 例如: n=57 → tens=5, ones=7
  // 例如: n=3  → tens=0, ones=3
  
  // ────────────────────────────────────────────────────
  // 步驟3: 輸出到對應的顯示器
  // ────────────────────────────────────────────────────
  // 重要修正: 原程式這裡寫反了!
  
  outputBCD(tens, false);  // 十位數輸出到左邊顯示器(toRight=false)
  outputBCD(ones, true);   // 個位數輸出到右邊顯示器(toRight=true)
  
  // 修正說明:
  // - 十位數應該顯示在左邊,所以toRight=false
  // - 個位數應該顯示在右邊,所以toRight=true
  // - 原程式這兩行的參數寫反了,導致數字顯示位置錯誤
}

// ============================================================================
// 程式結束 - 除錯與測試建議
// ============================================================================
/*
 * 測試步驟:
 * 1. 上傳程式到Arduino
 * 2. 打開序列埠監視器(9600 baud)
 * 3. 用手或物體遮擋感測器,觀察計數是否正確
 * 4. 快速移開物體,確認不會重複計數
 * 5. 連續快速遮擋,測試防抖動功能
 * 
 * 參數調整建議:
 * - 如果還是有重複計數: 增加BLOCK_TIME_MS (建議300-500ms)
 * - 如果漏計快速物體: 減少DEBOUNCE_MS (建議50-80ms)
 * - 如果計數太敏感: 增加DEBOUNCE_MS (建議100-150ms)
 * 
 * 硬體檢查要點:
 * 1. 確認感測器電源正確(通常5V)
 * 2. 確認感測器輸出邏輯(Active Low或Active High)
 * 3. 檢查線路是否有接觸不良
 * 4. 七段顯示器需要限流電阻(每段220Ω)
 */
